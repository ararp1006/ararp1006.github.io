---
title: JWT

date: 2023-12-05 23:00:00 +0900
categories: [Spring, Spring Security]
tags: [Spring, Spring Security]
math: true
mermaid: true

---



💡 JWT 공식 사이트 : https://jwt.io/

![image](https://github.com/ararp1006/mainProject/assets/130068083/e581084a-e88e-4d83-86b8-4f2ba9354366)

### **JWT(JSON Web Token)는**

데이터를 안전하고 간결하게 전송하기 위해 고안된 인터넷 표준 인증 방식으로써 

토큰 인증 방식에서 가장 범용적으로 사용되며 **JSON 포맷의 토큰 정보를 인코딩 후,** 

**인코딩 된 토큰 정보를 Secret Key로 서명(Sign)한 메시지를 Web Token으로써 인증 과정에 사용**

<hr>

### **JWT의 종류**

1. **액세스 토큰(Access Token)**
2. **리프레시 토큰(Refresh Token)**

**Access Token**은 보호된 정보들(사용자의 이메일, 연락처, 사진 등)에 접근할 수 있는 권한 부여에 사용

클라이언트가 처음 인증을 받게 될 때(로그인 시), **Access Token**과 **Refresh Token** 두 가지를 다 받지만, 실제로 권한을 얻는 데 사용하는 토큰은 **Access Token**입니다.

**권한을 부여받는 데**엔 **Access Token**만 가지고 있으면 되지만

이 **Access Token**을 만약 악의적인 사용자가 탈취한다면? 🤔 문제가 되기때문에

⭐ **Access Token**에는 비교적 `짧은 유효 기간`을 주어 탈취되더라도

 오랫동안 사용할 수 없도록 합니다

**Access Token**의 유효기간이 만료된다면 **Refresh Token**을 사용하여

 새로운 **Access Token**을 발급받습니다. 이때, 사용자는 다시 로그인 인증을 할 필요가 없습니다.

Refresh Token 도 탈취당한다면? 🤔

유효기간이 긴 **Refresh Token** 마저 탈취당하면 더 큰 문제가 됩니다

**Refresh Token**을 이용해 **Access Token**을 다시 발급받으면 사용자에게 피해를 입힐 수 있기 때문입니다.

그렇기 때문에 사용자의 `편의`보다 `정보를 지키는 것이 더 중요`한 웹 애플리케이션은 

**Refresh Token**을 사용하지 않도록 합니다

<hr>

### **JWT 구조**

![image](https://github.com/ararp1006/mainProject/assets/130068083/9f45c523-5d1f-41d6-bf17-4e474316d534)

1. **Header**
    
    Header는 이것이 어떤 종류의 토큰인지 어떤 알고리즘으로 Sign할지 정의합니다. 
    
    **JSON** Web Token이므로 JSON 포맷 형태로 정의합니다
    
    ```json
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```
    
    이 JSON 객체를 base64 방식으로 인코딩하면 JWT의 첫 번째 부분이 완성됩니다.
    
2. **Payload**
    
    Payload에는 서버에서 활용할 수 있는 사용자의 정보가 담겨 있습니다.
    
    어떤 정보에 접근 가능한지에 대한 권한을 담을 수도 있고, 사용자의 이름 등 필요한 데이터를 담을 수 있습니다.
    
    Payload는 다음으로 설명할 Signature를 통해 유효성이 검증될 정보이긴 하지만, **민감한 정보는 담지 않는 것이 좋습니다.**
    
    ```json
    {
      "sub": "someInformation",
      "name": "phillip",
      "iat": 151623391
    }
    ```
    
    첫 번째 부분과 마찬가지로, 위 JSON 객체를 base64로 인코딩하면 JWT의 두 번째 블록이 완성됩니다.
    
3. **Signature**
    
    base64로 인코딩 된 첫 번째, 그리고 두 번째 부분이 완성되었다면, 
    
    Signature에서는 원하는 비밀 키(Secret Key)와 Header에서 지정한 알고리즘을 사용하여
    
     **Header와 Payload에 대해서 단방향 암호화를 수행**합니다.
    
    이렇게 암호화된 메시지는 토큰의 위변조 유무를 검증하는 데 사용됩니다.
    
    예를 들어, 만약 HMAC SHA256 알고리즘(암호화 방법 중 하나)을 사용한다면 
    
    Signature는 아래와 같은 방식으로 생성됩니다.

    <hr>

### **JWT를 통한 인증의 장점**

1. **상태를 유지하지 않고(Stateless),** 
    
    **확장에 용이한(Scalable) 애플리케이션을 구현하기 용이합니다.**
    
    - 서버는 클라이언트에 대한 정보를 저장할 필요 없습니다.
        
        (토큰이 정상적으로 검증되는지만 판단합니다)
        
    - 클라이언트는 request를 전송할 때마다 토큰을 헤더에 포함시키면 됩니다.
        - 여러 대의 서버를 이용한 서비스라면 하나의 토큰으로 여러 서버에서 인증이 가능하기 때문에 JWT를 사용하는 것이 효과적입니다.
            
            만약에 세션 방식이라면 모든 서버가 해당 사용자의 세션 정보를 공유하고 있어야 합니다.
            
2. **클라이언트가 request를 전송할 때마다 자격 증명 정보를 전송할 필요가 없습니다.**
    - HTTP Basic 같은 인증 방식은 request를 전송할 때마다 자격 증명 정보를 포함해야 하지만
        
         JWT의 경우 토큰이 만료되기 전까지는 한 번의 인증만 수행하면 됩니다.
        
3. **인증을 담당하는 시스템을 다른 플랫폼으로 분리하는 것이 용이합니다.**
    - 사용자의 자격 증명 정보를 직접 관리하지 않고,
        
        Github, Google 등의 다른 플랫폼의 자격 증명 정보로 인증하는 것이 가능합니다.
        
    - 토큰 생성용 서버를 만들거나, 다른 회사에서 토큰 관련 작업을 맡기는 것 등
        
         다양한 활용이 가능합니다.
        
4. **권한 부여에 용이하다**
    - 토큰의 Payload(내용물) 안에 해당 사용자의 권한 정보를 포함하는 것이 용이합니다.

## **JWT를 통한 인증의 단점**

1. **Payload는 디코딩이 용이합니다.**
    - Payload는 base64로 인코딩 되기 때문에 토큰을 탈취하여 Payload를 디코딩하면
        
        토큰 생성 시 저장한 데이터를 확인할 수 있습니다. 
        
        따라서 Payload에는 민감한 정보를 포함하지 않아야 합니다.
        
2. **토큰의 길이가 길어지면 네트워크에 부하를 줄 수 있습니다.**
    - 토큰에 저장하는 정보의 양이 많아질수록 토큰의 길이는 길어집니다.
        
        따라서 request를 전송할 때마다 길이가 긴 토큰을 함께 전송하면 네트워크에 부하를 줄 수 있습니다.
        
3. **토큰은 자동으로 삭제되지 않습니다.**
    - 즉 한 번 생성된 토큰은 자동으로 삭제되지 않기 때문에 토큰 만료 시간을 반드시 추가해야 합니다.
    - 또한 토큰이 탈취된 경우 토큰의 기한이 만료될 때까지 토큰 탈취자가 해당 토큰을 정상적으로
        
         이용할 수 있으므로 만료 시간을 너무 길게 설정하지 않아야 합니다.