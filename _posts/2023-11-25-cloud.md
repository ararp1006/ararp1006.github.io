---
title: ☁️Cloud

date: 2023-11-23 19:00:00 +0900
categories: [Blogging, Study, Cloud]
tags: [Project,Study,Cloud]
math: true
mermaid: true

---
<details>
<summary>❓Cloud Computing이란?</summary>
<div markdown="1">
![image](https://github.com/ararp1006/Algorithm/assets/130068083/86874f71-f64a-42ad-927e-f1fafd8e92a5)

**클라우드 컴퓨팅은** 

인터넷을 통해 서버, 저장소, 데이터베이스, 네트워킹, 소프트웨어, 분석 및 인텔리전스를 포함한

컴퓨팅 서비스를 제공하는 것을 말합니다. 

이를 통해 더 빠른 혁신, 유연한 자원, 규모의 경제를 제공합니다. 

클라우드 컴퓨팅은 일반적으로 인프라스트럭처 서비스(IaaS), 플랫폼 서비스(PaaS), 소프트웨어 서비스(SaaS)와 같은 다양한 모델로 제공됩니다.
클라우드 제공자로부터 얼마만큼의 서비스를 제공받느냐에 따라서, 서비스의 형태가 구분됩니다.
</div>
</details>


<details>
<summary>❓배포란?</summary>
<div markdown="1">

**배포란**  개발한 서비스를 사용자들이 이용 가능하게 하는 일련의 과정입니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/15ca035a-f582-48e6-9c8a-fff86cf9dbc7)

**Development 단계**는 각자의 컴퓨터에서 코드를 작성하고 테스트하는 과정입니다.
개발 단계이기 때문에 실제 데이터를 이용하지 않고 더미 데이터를 이용해서 테스트합니다.

**Integration 단계**는 각자의 컴퓨터에서 작성한 코드를 합치는 과정입니다.
내가 작성한 코드가 다른 코드를 침범해서 오류를 일으키지 않는지, 

코드 간에 conflict가 있지는 않은지 확인하는 과정을 거칩니다.

**Staging 단계**에서는 실제 출시 단계인 Production 단계와 가장 유사한 환경에서 테스트를 진행합니다.
실제 데이터를 복사해서 문제가 있지 않은지 등 다양한 환경에서 테스트를 진행합니다.
또한 서비스와 관련된 부서 혹은 인원의 확인 과정을 거칩니다. 

예를 들면 작성된 코드가 마케팅팀 혹은 디자인팀이 예상했던 결과인지 확인을 거치는 과정입니다.

**Production 단계**는 개발된 서비스를 출시하는 단계입니다.
사용자가 접속할 수 있는 Production 환경에서 코드를 구동하고 서비스를 제공합니다.
실제 데이터를 가지고 서비스가 운영되기 때문에 문제가 생기면 안 되는 단계입니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/964fb9cf-968f-48ad-98c4-003048e6cbce)

**Development 환경**과 **Production 환경**은 서로 다를 수가 있습니다.

개발부터 배포까지 모든 것을 통제할 수 있는 상황이라면,  

똑같이 Production 환경을 구성할 수 있습니다.

그러나, 여러 명이 함께 작업하는 프로젝트라면 

jdk 버전도 제각각일 수 있고, 인증 정보나 데이터베이스 등에 접근하기 위해 사용하는 엔드포인트도 제각각일 겁니다.

**배포에서는, 환경의 차이를 이해하고 환경 설정을 코드와 분리하는 것이 중요합니다**

작성한 코드가 다른 환경에서 정상 작동할 수 있게 하려면, 

설정을 **환경 변수**(environment variable; envvars나 env라고도 불림)에 저장해야 합니다.

환경 변수는 코드 변경 없이 배포 때마다 쉽게 변경할 수 있습니다.
설정 파일과 달리, 잘못해서 코드 저장소에 올라갈 가능성도 낮습니다.

애플리케이션의 모든 설정이 정상적으로 코드 바깥으로 분리되어 있는지 확인할 수 있는 간단한 방법은 

어떠한 인증정보도 유출시키지 않고 코드가 지금 당장 오픈 소스가 될 수 있는지 확인하는 것입니다.
코드 상의 모든 곳에 절대 경로가 아닌 **상대 경로**를 사용해야 하며, 

`.properties` 등을 이용해 **환경 변수를 설정**해야합니다.

그 외에도 docker와 같은 가상화 도구는 환경 자체를 메타데이터로 담아서 

아예 모든 개발 환경을 통일시킵니다.

**Docker와 같은 개발 환경 자체를 통일시키는 솔루션**을 사용합니다.

</div>
</details>


<details>
<summary>❓EC2란?</summary>
<div markdown="1">

![image](https://github.com/ararp1006/Algorithm/assets/130068083/6b723b30-3bc6-4be8-8699-5eadccf5606d)

**EC2란** Elastic Compute Cloud의 약자로서

아마존 웹 서비스에서 제공하는 클라우드 컴퓨팅 서비스입니다.

클라우드 컴퓨팅은 인터넷(클라우드)을 통해

서버, 스토리지, 데이터베이스 등의 컴퓨팅 서비스를 제공하는 서비스입니다.
아마존에서 가상의 컴퓨터를 한 대 빌리는 것과 같습니다

EC2 서비스도 **사용한 만큼** 비용을 지불하기 때문에 '탄력적인'이라는 의미의 

Elastic이라는 단어를 사용합니다.
Elastic은 비용적인 부분뿐만이 아니라 필요에 따라 성능, 용량을 자유롭게 조절할 수 있습니다.

### EC2의 장점

첫 번째는 **구성하는 데 필요한 시간이 짧다는 것**입니다.

만약 PC를 구매한다면 구매해서 배송받기까지의 시간이 필요하지만

EC2 서비스는 몇 번의 클릭만으로 PC를 구성할 수 있습니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/c6741eb8-3351-4900-ae5a-c15ee9ff85b0)

**AMI**를 통해서 필요한 용도에 따라 **다양한 운영체제에 대한 선택이 가능**하다는 것입니다.

EC2에서는 AMI라는 다양한 템플릿을 제공하고 있어서 

<details>
<summary>AMI란?</summary>
<div markdown="1">
![image](https://github.com/ararp1006/Algorithm/assets/130068083/9fb81129-33a4-44b6-92dd-57225ae5e195)

**AMI**는 **소프트웨어 구성이 기재된 템플릿**입니다.

이미지 종류로는 단순히 운영체제(윈도우, 우분투 리눅스 등)만 깔려있는 템플릿을 선택할 수도 있고, 아예 특정 런타임이 설치되어 있는 템플릿이 제공되는 경우도 있습니다. (우분투 + node.js, 윈도우 + JVM 등)

</div>
</details>

필요에 따라 손쉽게 운영체제를 선택하고 구성할 수 있습니다.
운영체제뿐만이 아니라 CPU와 RAM, 용량까지도 손쉽게 구성할 수 있습니다.
### **인스턴스**란?

![image](https://github.com/ararp1006/Algorithm/assets/130068083/ead176fd-7756-43a0-af43-16ac5f84ddf2)

EC2는 **컴퓨터를 한 대 빌리는 것**이므로 컴퓨터로 할 수 있는 모든 일을 할 수 있습니다.

아마존이 전 세계에 만들어 놓은 데이터 센터(인프라)에 만들어져 있기 때문에
컴퓨터를 조작하기 위해 네트워크(인터넷)를 통해서 컴퓨터를 제어해야 한다는 차이점이 있을 뿐 일반적인 컴퓨터와 다른 점은 없습니다.

아마존 EC2를 통해서 할 수 있는 가장 기본적인 일은
웹서버를 설치하고 웹 서버를 통해서 사용자가 웹 브라우저를 통해 요청하는 서비스를 제공하는 것입니다.

**인스턴스**는 **1대의 컴퓨터를 의미하는 단위**이고 AWS에서 **컴퓨터를 빌리는 것을 인스턴스를 생성**한다고 합니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/c315f46d-e159-4745-b715-23470564b407)

**Instance**는 선택한 AMI를 토대로 구성됩니다.

AWS에는 상당히 많은 양의 AMI 세팅이 준비되어 있기 때문에 손쉽게 인스턴스의 운영체제를 구성할 수 있습니다.

세팅되어 있는 AMI 이외에도 필요에 따라 직접 AMI를 구성할 수도 있습니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/920a1042-b887-4dd2-af66-8bcf0041d3bf)

AWS **EC2 인스턴스를 생성한다는 것**은 **AMI를 토대로 운영체제, CPU, RAM 혹은 런타임 등이 구성된 컴퓨터를 빌리는 것**입니다.


</div>
</details>

<details>
<summary>❓RDS란?</summary>
<div markdown="1">

![image](https://github.com/ararp1006/Algorithm/assets/130068083/2d0f6082-82ab-4ae6-9e3f-8d2a0a46fab0)

**RDS**는 Relational Database Service의 약자로

AWS에서 제공하는 **관계형 데이터베이스 서비스**입니다. 

![image](https://github.com/ararp1006/Algorithm/assets/130068083/7ad57f80-d088-4b8f-be6e-9986d586ab24)

EC2 인스턴스에 **데이터베이스를 설치**하여 데이터를 관리하는 것은
자동으로 관리를 담당하는 부분이 매우 적기 때문에, 

사용자가 일일이 시간을 투자하여 데이터베이스 엔진의 설치와 버전 관리, 데이터 백업을 해야 합니다.

게다가 가용성과 내구성이 확보되지 않기 때문에 데이터베이스에 저장된 데이터가 유실되거나 

정상적으로 사용하지 못할 확률이 커지며, 

후에 필요에 따라 데이터베이스의 규모를 확장하기 어렵습니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/2f638faa-fd14-406b-9eb8-8877f92b9332)

**RDS**를 이용하면 데이터베이스 유지 보수와 관련된 일들을 RDS에서 전적으로 자동 관리합니다. 

사용자가 해야 할 일은 초기 설정을 제외하고

데이터베이스에 저장된 데이터를 관리하는 일 밖에 없기에 큰 편의성을 느낄 수 있습니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/2879abf2-dbec-483f-af7f-7b5c48b089de)

RDS 이용 시 얻을 수 있는 **장점**은 **다양한 데이터베이스 엔진 선택지를 제공**합니다.
데이터베이스 엔진마다 제공하는 기능이 조금씩 다르기에 필요와 목적에 맞게

데이터베이스 엔진을 선택하여 효율성을 높일 수 있습니다.

</div>
</details>

<details>
<summary>❓S3란?</summary>
<div markdown="1">

![image](https://github.com/ararp1006/Algorithm/assets/130068083/2a8b6a41-3e04-42e5-bec9-f9c6b93ec8d6)

**S3**는 Simple Storage Service의 약자로 **AWS에서 제공하는 클라우드 스토리지 서비스**입니다.

### S3의 장점

![image](https://github.com/ararp1006/Algorithm/assets/130068083/3b27704a-e605-476a-b778-950b7e0a4dd4)

**확장성**이 높으면 많은 시간과 수고를 들이지 않고 스토리지 규모를 확장/축소할 수 있습니다.

또한 S3에서는 스토리지의 용량을 무한히 확장할 수 있습니다. 

그리고 사용한 만큼만 비용을 지불하면 되기 때문에 비용적인 측면에서 매우 효율적입니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/9daec4c2-44fa-4dee-9ea1-543edeeb21c8)

스토리지의 **내구성이 높으면 저장된 파일을 유실할 가능성이 적어집니다.**

![image](https://github.com/ararp1006/Algorithm/assets/130068083/952f8f6e-15f0-4c17-816c-456245bc03ae)

**가용성이 높으면** 스토리지에 저장된 파일들을 **정상적으로 사용할 수 있는 시간이 길어집니다.** 

S3는 연간 99.99%의 스토리지 가용성을 보장하도록 설계가 되어 있습니다.

이는 다른 말로 1년 동안 S3에 파일을 저장했을 시, 

8.76 시간 동안만 스토리지를 이용하는 데 있어서 장애가 발생한다는 뜻입니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/2876db59-2ca1-4220-bca1-e04374cd2865)

**S3**는 다양한 스토리지 클래스를 제공합니다. 

저장소를 어떤 목적으로 활용할지에 따라 효율적으로 선택할 수 있는 스토리지 클래스가 달라집니다.
S3 사용자들이 대표적으로 많이 선택하는 스토리지 클래스는 두 가지가 있습니다.

**Standard 클래스**와 **Glacier 클래스**입니다.

**Standard 클래스**는 범용적인 목적으로 사용하기 좋습니다. 

데이터에 빠른 속도로 접근할 수 있고, 데이터 액세스 요청에 대한 처리 속도가 빠릅니다.

대신 데이터를 오래 보관하는 목적으로는 효율적인 선택지가 아닙니다. 

보관 비용이 높게 발생하기 때문입니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/d7baccad-1f95-46ba-aa78-d9d209cebad6)

장기적인 보관 목적으로 스토리지를 사용하실 때는 **Glacier**를 사용하는 것이 효율적입니다.
비록 저장된 데이터에 액세스하는 속도는 느리지만,

데이터를 보관하는 비용이 매우 저렴하다는 장점이 있습니다.

이 외에도 Standard-IA, One Zone-IA, S3 Glacier Deep Archive 등등 여러 가지 스토리지 클래스가 존재하여 사용자의 이용 목적에 따라 다양한 스토리지 클래스를 사용할 수 있습니다

![image](https://github.com/ararp1006/Algorithm/assets/130068083/a05079b3-b5d9-4957-b24c-518169ff91cf)

S3 사용 시 얻는 이점 중 하나로, 정적 웹 사이트 호스팅이 가능합니다. 

<details>
<summary>웹사이트 호스팅이란?</summary>
<div markdown="1">

정적 파일은 서버의 개입 없이 생성된 파일을 뜻합니다. 

반대로 클라이언트가 서버에 요청을 보내면, 

서버가 요청에 맞추어 그 자리에서 생성한 파일을 '동적' 파일이라고 부릅니다.

**웹 호스팅(Web Hosting)이란?**

웹 호스팅이란 **서버의 한 공간을 임대해 주는 서비스**를 뜻합니다.

웹 호스팅 업체들을 통해 개인 또는 단체가 웹 호스팅 업체가 제공하는 서버의 한 공간을 빌려서 원하는 서비스를 배포할 수 있습니다.

</div>
</details>

S3에서는 버킷이 사용자들이 정적 웹 사이트를 배포할 수 있는 공간을 제공합니다.

버킷이라는 저장 공간에 정적 파일을 업로드하고 

버킷을 정적 웹 사이트 호스팅 용도로 구성하면 정적 웹 사이트를 배포할 수 있습니다.

<details>
<summary>버킷&객체란?</summary>
<div markdown="1">

![image](https://github.com/ararp1006/Algorithm/assets/130068083/19eeb251-a03a-4968-b589-79f8e3605957)

**버킷이란** S3에 저장되는 파일들이 담기는 바구니입니다. 

파일을 저장하는 **최상위 디렉터리**라고도 설명할 수 있습니다.

S3에서 저장되는 **모든 파일은 버킷 안에 저장**되어야 하고, 

버킷에는 **무한한 양의 파일을 저장할 수** 있습니다. 

그리고 각각의 버킷은 이름을 가지고 있는데, 

버킷의 이름은 **버킷이 속해 있는 리전(버킷이 생성된 지역)에서 유일**해야 합니다.

또한 버킷 정책을 생성하여 해당 버킷에 대한 다른 유저의 접근 권한을 수정할 수 있습니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/5c9fb78e-957a-45dd-834a-cfe56dc70283)

S3에서 **버킷에 담기는 파일을 객체**라고 부릅니다.

S3에서 저장소에 데이터를 저장할 때 **키-값 페어 형식**으로 데이터를 저장합니다.

S3에 저장되는 **객체는 파일과 메타데이터로 구성**됩니다. 

파일은 키-값 페어 형식으로 데이터를 저장되고, 파일의 값에는 실제 데이터를 저장합니다. 

S3 객체의 값으로써 저장될 수 있는 데이터의 최대 크기는 5TB입니다.

파일의 **키는 각각의 객체를 고유하게 만들어주는 식별자 역할**을 합니다. 

파일의 키를 이용하여 원하는 객체를 검색할 수 있습니다.

**메타데이터**는 객체의 생성일, 크기, 유형과 같은 **객체에 대한 정보가 담긴 데이터**입니다. 

모든 **객체는 고유한 URL 주소를** 가지고 있습니다.
URL 주소는 http://[버킷의 이름].S3.amazonaws.com/[객체의 키]의 형태를 띠고, 

URL 주소를 통해서도 원하는 데이터에 접근할 수 있습니다.


</div>
</details>

</div>
</details>

<details>
<summary>❓Security Group이란?</summary>
<div markdown="1">

![image](https://github.com/ararp1006/Algorithm/assets/130068083/a05914ef-6777-4228-8213-21a07fa8e050)

**보안그룹이란** 인스턴스로 들어가고 인스턴스에서 나가는 트래픽에 대한 가상 방화벽입니다.

인스턴스로 들어가는 트래픽은 **인바운드**

인스턴스에서 나가는 트래픽을 **아웃바운드**라고 합니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/b7f992c4-8fd2-4440-b351-16796e21698c)

**인바운드규칙**은 **EC2 인스턴스로 들어오는 트래픽에 대한 규칙**입니다.

인바운드 규칙에 허용되지 않은 규칙은 **인스턴스로 접근하지 못하도록 필터링** 됩니다.

EC2 인스턴스를 생성하면 기본적으로 SSH 접속을 위한 SSH 규칙만 생성되어 있습니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/94e0882f-7a97-4dab-8592-3749a361e040)

**아웃바운드 규칙**은 **EC2 인스턴스에서 나가는 트래픽에 대한 규칙**입니다.

EC2 인스턴스를 생성하면 기본적으로 나가는 모든 트래픽을 허용합니다.

![image](https://github.com/ararp1006/Algorithm/assets/130068083/d2bd098d-d514-460f-bd2b-56c49ff3c8c6)


</div>
</details>

<details>
<summary>❓Docker란?</summary>
<div markdown="1">

[📃도커 공식 문서](https://docs.docker.com/reference/)

![image](https://github.com/ararp1006/Algorithm/assets/130068083/7125f447-df3f-4c43-80a3-2d5ea9d51408)

### **도커란?**

개발 시 application을 쉽고 빠르게 구축, 공유 및 실행할 수 있는 소프트웨어입니다. 

만약 프로젝트 시작 시, 환경설정부터 기본 세팅을 해야 합니다.

하지만 도커를 사용하면 프로젝트마다 반복되는 세팅을 할 필요가 없습니다.

Docker만 설치되어 있다면, OS와 CPU에 상관없이 컨테이너를 사용 가**능**합니다.

즉, Spring, Nodejs, Django, Nextjs 등등에 관련 없이 컨테이너에만 넣으면 

모두 동일하게 실행이 가능합니다. 

이때 주의해야 할 점은 컨테이너를 삭제하면 내부의 데이터가 모두 삭제되기 때문에 

주요한 데이터는 외부 스토리지에 저장이 필요합니다.

- ****도커 컨테이너란?****
    
    도커 이미지를 바탕으로 생성된 가볍고 독립적인 실행 단위입니다. 
    
    도커 컨테이너는 호스트 OS와 다른 컨테이너와 격리되어 있으며, 
    
    필요에 따라 자원을 할당받아 실행됩니다. 
    
    이렇게 생성된 도커 컨테이너는 마치 가상머신처럼 동작하지만, 
    
    오버헤드가 적기 때문에 가볍고 빠르게 실행됩니다.
    
    [컨테이너와 가상머신](https://www.notion.so/57bc80bbc82b4027bb89419f91ccc5b0?pvs=21)
    
    **도커 컨테이너의 특징**
    
    1. **가볍고 효율적:** 가상 머신과 비교하여 컨테이너는 호스트 운영 체제의 커널을 공유하여 가볍고 효율적으로 동작합니다.
    2. **이식성:** 도커 컨테이너는 어디에서나 실행될 수 있습니다. 호스트 환경의 구성과 관계없이 일관된 동작을 제공합니다.
    3. **확장성:** 도커는 여러 개의 컨테이너를 클러스터로 관리할 수 있으며, 필요에 따라 컨테이너의 수를 동적으로 조정할 수 있습니다.
    4. **빠른 배포:** 이미지를 통해 응용 프로그램 및 환경을 패키징하고 빠르게 배포할 수 있습니다. 이를 통해 개발과 운영 사이의 간극을 줄일 수 있습니다.
    
    **도커 컨테이너의 구성**
    
    1. **이미지(Image):** 실행할 애플리케이션, 도구, 라이브러리 등을 포함하는 읽기 전용 템플릿입니다.
    2. **컨테이너(Container):** 이미지를 기반으로 생성된 실행 가능한 인스턴스로, 격리된 환경에서 애플리케이션을 실행합니다.
    3. **레지스트리(Registry):** 도커 이미지를 저장하고 관리하는 곳으로, 도커 허브(Docker Hub)와 같은 공개 레지스트리나 사설 레지스트리를 사용할 수 있습니다.
- ****도커 저장소란?****
    
    도커 저장소는 도커 이미지를 저장하고, 관리하며, 공유할 수 있는 곳입니다. 
    
    ****도커 저장소의 종류****
    
    - Docker Hub
        - Docker Hub는 도커에서 제공하는 공식 저장소입니다. 무료로 사용할 수 있고, 개인적으로 사용하는 것뿐만 아니라 공개적으로 이미지를 공유할 수 있습니다. Docker Hub는 이미지를 검색하고 다운로드할 수 있는 검색 엔진도 제공합니다.
    - Private Registry
        - Private Registry는 비공개 저장소로서, 회사나 조직 내에서 도커 이미지를 공유할 목적으로 구축합니다. 회사나 조직 내부에서만 접근이 가능하며, 보안성이 높습니다.
    - Public Registry
        - Public Registry는 공개 저장소로서, 누구나 이미지를 등록하고 공유할 수 있습니다. Public Registry에서는 누구나 이미지를 검색하고 다운로드할 수 있습니다.
- **도커이미지란?**
    
    도커 이미지(Docker Image)는 도커 컨테이너를 생성하기 위한 템플릿입니다. 
    
    도커 이미지는 애플리케이션을 실행하는 데 필요한 모든 환경과 라이브러리, 소스 코드 등을 포함하고 있으며, 이를 기반으로 도커 컨테이너가 생성됩니다.
    
     도커 이미지는 불변하며, 한 번 생성되면 수정할 수 없습니다.
    
</div>
</details>

<details>
<summary>❓CI</summary>
<div markdown="1">

개발자들이 새로운 코드를 작성하고 이전 코드와 함께

**자동으로 빌드하고 테스트를 수행하는 프로세스**로 매우 중요한 개발 방법론 중 하나입니다

1. **코드 품질 향상**: CI는 코드를 자동으로 빌드하고 테스트하므로 개발자들은 실수를 줄일 수 있습니다. 이는 코드 품질 향상에 큰 도움이 됩니다.
2. **더 빠른 피드백**: CI는 새로운 코드를 작성하고 이전 코드와 함께 자동으로 빌드하고 테스트하므로, 문제가 발생하면 빠르게 발견할 수 있습니다. 이는 더 빠른 피드백을 받을 수 있게 해줍니다.
3. **더 높은 효율성**: CI는 빌드 및 테스트를 자동화하므로, 개발자들은 수동으로 작업하는 시간을 절약하고 더 많은 시간을 실제 개발에 할애할 수 있습니다.


<details>
<summary>지속적 통합 (CI : Continuous Integration) 도구</summary>
<div markdown="1">

## ****Jenkins [🔗 공식 사이트](https://www.jenkins.io/)**

![image](https://github.com/ararp1006/Algorithm/assets/130068083/ab340245-a47c-4b4b-a370-13fead1adfd2)

**Jenkins**는 

소프트웨어 구축, 테스트, 제공 또는 배포와 관련된 모든 종류의 작업을 자동화하는 데 

사용할 수 있는 독립형 오픈 소스 자동화 서버입니다.

Jenkins는 기본 시스템 패키지, Docker를 통해 설치하거나 

JRE(Java Runtime Environment)가 설치된 시스템에서 독립 실행형으로 실행할 수도 있습니다.

### ****GitHub Actions [🔗 공식 사이트](https://github.com/features/actions)**

![image](https://github.com/ararp1006/Algorithm/assets/130068083/714a6b76-cfa9-4a37-93c9-4f7ef4f1368b)

**GitHub Actions는**

빌드, 테스트 및 배포 파이프라인을 자동화할 수 있는 지속적 통합 및 지속적 배포(CI/CD) 플랫폼

GitHub 저장소를 기반으로 소프트웨어 개발 Workflow를 자동화할 수 있는 툴입니다.

GitHub 마켓 플레이스를 통해 여러 사람이 공유한 Workflow를 찾을 수 있으며, 자신이 직접 만들어 공유할 수도 있습니다.


</div>
</details>


## ****Github Actions를 통한 컨테이너 지속적 통합****

![image](https://github.com/ararp1006/Algorithm/assets/130068083/db7fd012-2885-4fea-9fc4-a6ca3d41a61b)

</div>
</details>




<details>
<summary>❓CD</summary>
<div markdown="1">

안녕

</div>
</details>


[^fn-nth-2]: The 2nd footnote source