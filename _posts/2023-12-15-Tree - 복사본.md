---
title: Hash
date: 2024-03-28 23:00:00 +0900
categories: [Study, 자료구조/알고리즘]
tags: [자료구조/알고리즘]
math: true
mermaid: true

---
## **Hash란?**

![image](https://github.com/ararp1006/Algorithm/assets/130068083/4bb688be-6cfe-4340-b39c-6075ccc16171)


<span style="color:red">**임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수를 말합니다.**</span>

이러한 해시 함수를 적용하면 어떠한 크기의 입력 데이터도 항상 일정한 길이의 해시값을 출력합니다. 

따라서 입력 데이터의 크기에 상관없이 동일한 길이의 해시값을 갖게 됩니다.




## **암호화에서의 Hash**

많은 기관에서 사용자 ID와 비밀번호가 데이터베이스 테이블에 보관합니다. 

로그인 시도를 하면 시스템이 사용자 ID를 확인해서 사용자가 입력한 암호와 테이블 내 있는 암호가 일치하는지 비교합니다. 

가장 기본적인 암호 보관 포맷은 **“암호화되지 않아 읽을 수 있는 데이터”** 로 저장되는 평문입니다. 

그러나 이 수준의 보안은 사실상 해커가 쉽게 해킹할 수 있기때문에 취약할 수 밖에 없습니다.

이를 위한 해결책?



## **해싱알고리즘**

해싱 알고리즘은 <span style="color:red">**“데이터를 최종 사용자가 원문을 추정하기 힘든 더 작고, 뒤섞인 조각으로 나누는 것”**</span>을 의미합니다. 

해시 함수는 특정 입력 데이터에서 고정 길이값 또는 해시값을 생성하는 알고리즘입니다. 

이는 평문을 암호화된 텍스트로 변환하고 해독을 통해 암호화된 텍스트를 원래 평문으로 바꾸는 암호화와는 다릅니다. 

해싱 알고리즘의 경우, 암호화 해시 함수로 평문을 해시 처리한 텍스트로 바꿔, 해커가 알아보기 힘들게 합니다. 

해시 길이는 160~ 512비트가 좋다고 합니다. 하지만  원문을 다시 만들어낼 수 있는 방법을 제공하지 않습니다.

암호 보안을 확보하고자 한다면, 암호를 해시 처리한 후 사용자 ID와 함께 짝을 지어 데이터베이스 테이블에 보관해줍니다.

로그인 시, 입력한 암호는 해시 처리되어 데이터베이스 테이블의 해시 처리된 입력값과 비교됩니다.


## **해싱 알고리즘 장단점**