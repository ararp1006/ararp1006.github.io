---
title: Hash
date: 2024-03-28 17:00:00 +0900
categories: [Study, ]
tags: [JAVA]
math: true
mermaid: true

---

![image](https://github.com/ararp1006/Algorithm/assets/130068083/4bb688be-6cfe-4340-b39c-6075ccc16171)

## **Hash란?**

<span style="color:red">**임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수를 말합니다**.</span>

이러한 해시 함수를 적용하면 어떠한 크기의 입력 데이터도 항상 일정한 길이의 해시값을 출력합니다.

key의 길이 > hash의 길이

따라서 입력 데이터의 크기에 상관없이 동일한 길이의 해시값을 갖게 됩니다.



## **암호화에서의 Hash**


많은 기관에서 사용자 ID와 비밀번호가 데이터베이스 테이블에 보관합니다.

로그인 시도를 하면 시스템이 사용자 ID를 확인해서 사용자가 입력한 암호와 테이블 내 있는 암호가 일치하는지 비교합니다.

가장 기본적인 암호 보관 포맷은 “암호화되지 않아 읽을 수 있는 데이터” 로 저장되는 평문입니다.

그러나 이 수준의 보안은 사실상 해커가 쉽게 해킹할 수 있는 디지털 종이 조각 위에 자격 증명을 써 놓은 거나 마찬가지이기 때문에 딱히 논할 가치가 없습니다.

이런 시스템은 취약할 수 밖에 없습니다. 이를 위한 해결책?



## **해싱알고리즘**


해싱 알고리즘은 <span style="color:red">**“데이터를 최종 사용자가 원문을 추정하기 힘든 더 작고, 뒤섞인 조각으로 나누는 것”**</span>을 의미합니다.

해시 함수는 특정 입력 데이터에서 고정 길이값 또는 해시값을 생성하는 알고리즘입니다.

이는 평문을 암호화된 텍스트로 변환하고 해독을 통해 암호화된 텍스트를 원래 평문으로 바꾸는 암호화와는 다릅니다.

해싱 알고리즘의 경우, 암호화 해시 함수로 평문을 해시 처리한 텍스트로 바꿔, 해커가 알아보기 힘들게 합니다.

해시 길이는 160~ 512비트가 좋다고 합니다. 하지만 원문을 다시 만들어낼 수 있는 방법을 제공하지 않습니다.

암호 보안을 확보하고자 한다면, 암호를 해시 처리한 후 사용자 ID와 함께 짝을 지어 데이터베이스 테이블에 보관해줍니다.

로그인 시, 입력한 암호는 해시 처리되어 데이터베이스 테이블의 해시 처리된 입력값과 비교됩니다.



## **해싱알고리즘 종류**

**SHA(Secure Hash Algorithm)**

![image](https://github.com/ararp1006/Algorithm/assets/130068083/554cae3a-41b7-4106-9657-723690fbe78e)



> SHA-256의 동작원리

![image](https://github.com/ararp1006/Algorithm/assets/130068083/829c69a3-e852-40e6-ab69-3c076cb59605)


> 먼저 변환하고자 하는 문자열을 바이너리 형태로 변환합니다. 바이너리 코드는 0과 1로 나타납니다

> 바이너리 데이터는 512 비트의 블락들로 나뉩니다. 만약 블락이 512보다 작다면 패딩을 통해 사이즈를 늘려주고 블락이 512보다 크다면 자릅니다.

> 마지막 64 비트는 제외하고 모두 0으로 채워줍니다. 

> 마지막 64비트는 원래 문자열의 길이를 big endian 정수로 나타냅니다. 

> 앞서 나눈 블락들을 다시 32비트로 자릅니다.

>  앞서 512비트로 나눈 블락들을 다시 32비트로 자릅니다.

> 그리고나서 각 블락별로 해시값을 구하는데, 첫번째 블락의 해시 결과가 두번째 블락의 입력값으로 사용되며

 두번째 블락의 해시 결과는 첫번째 블락의 해시 결과와 두번째 블락 데이터와 결합해서 구해집니다.

> 최종적으로 256비트의 해시값이 생성되는데 이것이 SHA-256 결과값입니다.


SHA-256은 아직까지 해킹사례와 충돌 사례가 없습니다. 

그래서 SHA-256은 비트코인 네트워크와 같이 세계적으로 곳곳에서 사용되고 있습니다.



## **해싱 알고리즘 장점**

**무결성 보호**

해시 함수는 데이터의 무결성을 보호하는 데 사용됩니다. 

데이터의 해시값을 계산하여 저장해 둔 후, 데이터가 변경되었는지 확인할 때 저장된 해시값과 현재 데이터의 해시값을 비교합니다. 

만약 해시값이 다르면 데이터가 변경되었다는 것을 알 수 있습니다.

**빠른 계산**

해시 함수는 일반적으로 빠르게 계산될 수 있는 특성을 갖고 있습니다.

따라서 무결성 검증 및 보호에 효율적으로 사용될 수 있습니다.

**고정된 길이의 출력**

해시 함수는 임의의 입력에 대해 항상 고정된 길이의 출력을 생성합니다.

이는 데이터의 크기에 관계없이 항상 동일한 크기의 해시값을 갖게 되어 데이터 관리에 용이합니다.



## **해싱 알고리즘 단점**

**단방향성** 

해시 함수는 일방향 함수로, 해시값으로부터 원본 데이터를 복원하는 것은 매우 어렵거나 불가능합니다.

이는 데이터의 암호화에는 적합하지만, 해시된 데이터를 다시 복원해야 하는 경우에는 문제가 될 수 있습니다.

**해쉬 충돌**

해시 함수는 서로 다른 입력에 대해 동일한 해시값을 반환할 수 있는 충돌 가능성이 있습니다. 

따라서 충돌을 최소화하기 위해 충돌 저항성이 높은 안전한 해시 함수를 선택해야 합니다.


**무작위성 부족**

일부 해시 함수는 입력에 대해 충돌을 일으키기 쉬운 패턴을 갖고 있을 수 있습니다. 

이는 악의적인 공격자가 충돌을 악용하여 보안을 침해하는 데 이용될 수 있습니다.

